"""
plotting.py
-----------

Reusable visualisation helpers for the *Equity Factor Alpha* project.
Keeping every figure generated by the CLI, notebooks and tests
consistent prevents the “one plot = one style” chaos you often see in
research code.  The API mirrors that of my crypto project but
supports saving figures in PNG format by default.  Matplotlib is
used directly to avoid external dependencies.

I’m a strong believer in reproducibility and clear communication.  In
my own career, whether presenting to colleagues or posting an
analysis online, I’ve found that consistent styling helps focus the
discussion on the results rather than the aesthetics.  This module
encapsulates those preferences by defining a single plotting function
with sensible defaults.  It’s a small touch that contributes to a
morally compliant workflow: transparent figures make it easier for
others to audit and critique our findings.
"""

from __future__ import annotations

from pathlib import Path
from typing import Any

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

__all__ = ["plot_equity", "plot_returns_vs_benchmark"]


def _ensure_series(obj: pd.Series | pd.DataFrame) -> pd.Series:
    """Accept a 1‑column DataFrame or a Series; always return a Series."""
    if isinstance(obj, pd.DataFrame):
        if obj.shape[1] != 1:
            raise ValueError(
                f"DataFrame must have exactly one column (got {obj.shape[1]})."
            )
        return obj.iloc[:, 0]
    return obj


def plot_equity(
    equity: pd.Series | pd.DataFrame,
    title: str | None = None,
    *,
    ax: Any | None = None,
    figsize: tuple[int, int] = (10, 5),
    show: bool = True,
    save_path: str | Path | None = None,
    metrics: dict[str, float] | None = None,
    initial_capital: float | None = None,
    scale: str = "currency",
) -> plt.Axes:
    """
    Plot an equity curve with sensible defaults.

    Parameters
    ----------
    equity
        Cumulative PnL time‑series (Series or 1‑col DataFrame).
    title
        Figure title; defaults to the Series/column name.
    ax
        Matplotlib Axes to draw on (optional).
    figsize
        Figure size, if we create our own figure.
    show
        Call ``plt.show()`` automatically.
    save_path
        If given, save the figure (filetype inferred from suffix).  PNG is
        recommended for light file sizes.
    metrics
        Optional dictionary of metric names and values to display on the plot.
    initial_capital
        Starting portfolio capital in the same currency as *equity*. Required when ``scale="pct"``.
    scale
        "currency" plots portfolio value in £ starting at *initial_capital* (if provided) or cumulative PnL otherwise.
        "pct" plots cumulative percentage return = 100 × ((initial_capital + PnL) / initial_capital − 1).

    Returns
    -------
    matplotlib.axes.Axes
        The Axes the curve was drawn on.
    """
    ser: pd.Series = _ensure_series(equity)
    if title is None:
        title = ser.name or "Equity Curve"

    created_fig = False
    if ax is None:
        fig, ax = plt.subplots(figsize=figsize)
        created_fig = True

    # Transform depending on requested scale
    if scale == "pct":
        if initial_capital is None:
            raise ValueError("initial_capital must be provided when scale='pct'")
        ser_plot = 100.0 * ((initial_capital + ser) / initial_capital - 1.0)
        ylabel = "Cumulative Return (%)"
    elif scale == "currency":
        if initial_capital is not None:
            ser_plot = initial_capital + ser
            ylabel = "Portfolio Value (£)"
        else:
            ser_plot = ser
            ylabel = "Cumulative PnL (base currency)"
    else:
        raise ValueError("scale must be 'pct' or 'currency'")

    ax.plot(ser_plot.index, ser_plot.values, linewidth=1.4)
    ax.set_title(title)
    ax.set_xlabel("Date")
    ax.set_ylabel(ylabel)
    ax.grid(True, linestyle="--", linewidth=0.5, alpha=0.7)
    lines = []
    if metrics is not None:
        lines.extend(f"{k}: {v:.4f}" for k, v in metrics.items() if pd.notna(v))
    if scale == "currency" and initial_capital is not None:
        lines.append(f"Initial £{initial_capital:,.0f}")
    if lines:
        ax.text(
            0.02,
            0.98,
            "\n".join(lines),
            transform=ax.transAxes,
            va="top",
            ha="left",
            fontsize=8,
            bbox=dict(facecolor="white", alpha=0.6, edgecolor="none"),
        )
    if created_fig:
        fig.tight_layout()
    if save_path is not None:
        Path(save_path).parent.mkdir(parents=True, exist_ok=True)
        plt.savefig(save_path, dpi=300)
    if show:
        plt.show()
    return ax


def plot_returns_vs_benchmark(
    strategy: pd.Series,
    benchmark: pd.Series,
    *,
    alpha: float | None = None,
    beta: float | None = None,
    ax: Any | None = None,
    figsize: tuple[int, int] = (6, 6),
    show: bool = True,
    save_path: str | Path | None = None,
) -> plt.Axes:
    """
    Scatter plot of strategy versus benchmark returns.

    Parameters
    ----------
    strategy, benchmark
        Synchronous periodic returns; will be aligned on their indices.
    alpha, beta
        Pre‑computed regression coefficients to annotate (optional).
    """
    s, b = pd.Series(strategy).align(pd.Series(benchmark), join="inner")
    if ax is None:
        fig, ax = plt.subplots(figsize=figsize)
    ax.scatter(b, s, s=10, alpha=0.6)
    # Fit line
    if len(s) >= 2:
        m, c = np.polyfit(b, s, 1)
        xs = np.linspace(b.min(), b.max(), 100)
        ax.plot(xs, m * xs + c, linewidth=1.2)
    ax.set_xlabel("Benchmark returns")
    ax.set_ylabel("Strategy returns")
    ax.set_title("Strategy vs Benchmark – α/β")
    ann = []
    if alpha is not None and pd.notna(alpha):
        ann.append(f"α = {alpha:.4f}")
    if beta is not None and pd.notna(beta):
        ann.append(f"β = {beta:.2f}")
    if ann:
        ax.text(
            0.05,
            0.95,
            "\n".join(ann),
            transform=ax.transAxes,
            va="top",
            ha="left",
            fontsize=9,
            bbox=dict(facecolor="white", alpha=0.6, edgecolor="none"),
        )
    ax.grid(True, linestyle="--", linewidth=0.5, alpha=0.7)
    if save_path is not None:
        Path(save_path).parent.mkdir(parents=True, exist_ok=True)
        plt.savefig(save_path, dpi=300)
    if show:
        plt.show()
    return ax
